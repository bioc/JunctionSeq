\name{readJunctionSeqCounts}
\docType{methods}
\alias{readJunctionSeqCounts}
\title{
   Read junctionSeq count files
}
\description{
   This function loads read-count data (usually produced by QoRTs) and 
   compiles them into a \code{JunctionSeqCountSet} object.
   
   This function is called internally by the \code{\link{runJunctionSeqAnalyses}} 
   function, and thus for most purposes users should not need to call this
   function directly. It may be useful to advanced users performing non-standard
   analyses.
}
\usage{
readJunctionSeqCounts(countfiles, countdata,
    samplenames,  design,
    flat.gff.file, 
    test.formula1 = formula(~ sample + countbin + condition : countbin),
    analysis.type = c("junctionsAndExons","junctionsOnly","exonsOnly"),
    nCores = 1,
    use.exons, use.junctions, 
    use.known.junctions = TRUE, use.novel.junctions = TRUE,
    use.multigene.aggregates = FALSE,
    gene.names,
    verbose = TRUE,
    method.countVectors = c("geneLevelCounts","sumOfAllBinsForGene",
                            "sumOfAllBinsOfSameTypeForGene"),
    noDESeqMatrix = FALSE
)
}

\arguments{
  \item{countfiles}{
    Character vector. The filenames of the count files generated by QoRTs. The counts must all
    be generated using equivalent QoRTs parameters. The strandedness must be the same, as well
    as the inclusion of novel junctions.
  }
  \item{countdata}{
    List. An alternative parameterization. Instead of supplying count files using the 
    countfiles parameter, you can pass a list of data frames, one for each sample. 
    Each data frame should contain two columns: the first should be the feature id 
    and the second should be the counts. This list must have the same length as 
    the samplenames parameter.
  }
  
  \item{samplenames}{
    Character vector. A vector of full sample names, in the same order as the countfiles parameter. 
  }
  \item{design}{
    A data frame containing the condition variable and all desired covariates. All variables should be
    factors.
  }

  \item{flat.gff.file}{
    Character string. The filename of the "flat" gff annotation file. Can be gzip-compressed. 
    This "flat" gff file must be produced by the QoRTs jar utility using the makeFlatGtf or 
    mergeNovelSplices functions (depending on whether inclusion of novel splice junctions is desired).
    
    NOTE: This option is technically optional, but strongly recommended. If it is not included, then 
    attempts to plot the results will crash unless (non-default) options are used to deactivate the 
    plotting of genomic coordinates and transcript information
  }
  \item{test.formula1}{
    For advanced users. The base formula for the alternate hypothesis model used in the hypothesis tests.
    
    NOTE: the biological condition to be tested must be named "condition".
  }
  \item{analysis.type}{
    Character string. One of "junctionsAndExons", "junctionsOnly", or "exonsOnly". This parameter determines 
    what type of analysis is to be performed. By default JunctionSeq tests both splice junction 
    loci and exonic regions for differential usage (a "hybrid" analysis). This parameter
    can be used to limit analyses specifically to either splice junction loci or exonic regions.
  }
  \item{nCores}{
    The number of cores to use. Note that multicore functionality may not be available on all platforms.
  }

  \item{use.exons}{
    Logical value. This is an alternate parameterization of the \code{analysis.type} parameter. 
    If \code{TRUE}, then exonic region loci will be included in the analyses and will be tested for 
    differential usage. If this parameter is set, then parameter \code{use.junctions} must also be set.
  }
  \item{use.junctions}{
    Logical value. This is an alternate parameterization of the \code{analysis.type} parameter. 
    If \code{TRUE}, then splice junction loci will be included in the analyses and will be tested for 
    differential usage. If this parameter is set, then parameter \code{use.exons} must also be set.
  }

  \item{use.known.junctions}{
    Logical value. If \code{TRUE}, then known splice junctions will not be filtered out prior to analysis. Note: this is overidden if use.junctions is \code{FALSE} or if \code{analysis.type} is set to "exonsOnly".
  }
  \item{use.novel.junctions}{
    Logical value. If \code{TRUE}, then novel splice junctions will not be filtered out prior to analysis. Note: this is overidden if use.junctions is \code{FALSE} or if \code{analysis.type} is set to "exonsOnly".
  }
  
  \item{use.multigene.aggregates}{
    Logical value. Whether to attempt to test "aggregate genes" which consist of multiple genes that overlap with one another. Note that inclusion of aggregate genes may affect the false discovery rate, since by their very nature aggregate genes will often show differential splice junction usage, as the two genes will often be regulated independently.
  }
  \item{gene.names}{
    data.frame. This optional parameter can be used to decoder the gene id's used in the actual analysis into gene symbols or gene names for general readability.
    This must be a text file name or data.frame with two columns of character strings. The first must be the gene ID's, and the second must be the gene names (as you wish them to appear in the plots). Genes
    are allowed to have multiple gene names, in which case they will be separated by commas.
    The gene names will be used in the plots and figures.
  }
  
  \item{verbose}{if TRUE, send debugging and progress messages to the console / stdout.}
  \item{method.countVectors}{
    Character string. Can be used to apply alternative methodologies or implementations. Intended for advanced users who have strong opinions about the underlying statistical methodologies.

    Determines the type of count vectors to be used in the model framework. By default JunctionSeq compares the counts for a specific feature against the counts across the rest 
    of the gene minus the counts for the specific feature. Alternatively, the sum of all other features on the gene can be used, like in DEXSeq. The advantage to the default JunctionSeq
    behavior is that no read or read-pair is ever counted more than once in any model. Under DEXSeq, some reads may cover many exonic segments and thus be counted repeatedly.
  }
  \item{noDESeqMatrix}{
    Suppresses the internal generation of a DESeq2 object. Depending on the options used this will break many downstream steps, and is for advanced usage only.
  }
}
\value{
  A JunctionSeqCountSet.
}


\examples{
########################################
#Set up example data:
decoder.file <- system.file(
                  "extdata/annoFiles/decoder.bySample.txt",
                  package="JctSeqData");
decoder <- read.table(decoder.file,
                  header=TRUE,
                  stringsAsFactors=FALSE);
gff.file <- system.file(
            "extdata/tiny/withNovel.forJunctionSeq.gff.gz",
            package="JctSeqData");
countFiles <- system.file(paste0("extdata/tiny/",
     decoder$sample.ID,
     "/QC.spliceJunctionAndExonCounts.withNovel.forJunctionSeq.txt.gz"),
     package="JctSeqData");
########################################
#Advanced Analysis:

#Make a "design" dataframe:
design <- data.frame(condition = factor(decoder$group.ID));
#Read the QoRTs counts.
jscs = readJunctionSeqCounts(countfiles = countFiles,
           samplenames = decoder$sample.ID,
           design = design,
           flat.gff.file = gff.file
);

}