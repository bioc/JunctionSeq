\name{JunctionSeqCountSet-class}
\Rdversion{1.1}
\docType{class}
\alias{JunctionSeqCountSet-class}
\alias{JunctionSeqCountSet}

\title{Class \code{"JunctionSeqCountSet"}}
\description{
  A \code{JunctionSeqCountSet} is a container class that 
  contains all information pertaining to a JunctionSeq analysis
  and dataset. In general, these methods and slots will not be used
  by the end-users. In general, JunctionSeqCountSet objects will be 
  created by \code{\link{readJunctionSeqCounts}} or 
  \code{\link{runJunctionSeqAnalyses}} and are to be
  manipulated byhigh-level JunctionSeq functions such as 
  \code{\link{estimateEffectSizes}} or \code{\link{fitJunctionSeqDispersionFunction}}.
  
  The methods documented here are for use by advanced users only.
}

\section{Constructor}{
  \describe{
    \item{}{
      \code{newJunctionSeqCountSet( countData, 
                              geneCountData, 
                              design, 
                              geneIDs, 
                              countbinIDs, 
                              featureIntervals=NULL, 
                              transcripts=NULL)}:
      Creates a new JunctionSeqCountSet
      
      \describe{
        \item{\code{countData}}{
    A matrix of junction-level count data of non-negative integer values. 
    The rows correspond to counts for each splice-junction counting bin, 
    the columns correspond to samples. Note that biological 
    replicates should each get their own column, while the 
    counts of technical replicates (i.e., several sequencing 
    runs/lanes from the same sample) should be summed up 
    into a single column.
        }
        \item{\code{geneCountData}}{
    A matrix of gene-level count data of non-negative integer values. 
    The rows correspond to counts for each gene, 
    the columns correspond to samples. Note that biological 
    replicates should each get their own column, while the 
    counts of technical replicates (i.e., several sequencing 
    runs/lanes from the same sample) should be summed up 
    into a single column. Must have the same dimensions as countData.
        }
        \item{\code{design}}{
    A data frame consisting of all factors to be included in the analysis.
    All columns should be factors. Each column should represent a different variable,
    each row should represent a different sample. The number of rows must equal the
    number of columns in geneCountData and countData.
        }
        \item{\code{geneIDs}}{
    A character vector of gene indentifiers for each splice junction. The length must
    equal the number of rows in countData.
        }
        \item{\code{countbinIDs}}{
    A character vector of splice-junction-locus indentifiers for each splice junction. The length must
    equal the number of rows in countData.
        }
        \item{\code{featureIntervals}}{
    Optional. A data.frame with 4 columns: "chr", "start", "end", and "strand". chr and strand should 
    be character vectors or factors, start and end must be integers.  
        }
        \item{\code{transcripts}}{
    Optional. Character vector listing the transcripts that each splice junction belongs to. Some junctions
    may belong to more than one transcripts. In this case, transcripts should be separated with the "+" character.
        }
      }
      
      This constructor function SHOULD NOT BE USED in normal operation. 
      Instead you should use the \code{\link{readJunctionSeqCounts}} 
      function, which returns a new \code{JunctionSeqCountSet}.
    }
  }
}

\details{
  Slots:
  \describe{
    \item{\code{designColumns }}{  
      A character vector with the column names in the \code{design} data.frame.
    }
    \item{\code{dispFitCoefs}}{  
      The dispersion fit coefficients.
    }
    \item{\code{fittedMu}}{  
      Fitted mu values generated by DESeq2 code.
    }
    \item{\code{dispFunctionType}}{  
      A list of various variables defining the dispersion functon used.
    }
    \item{\code{dispFunction}}{  
      A function that converts a base mean to a fitted dispersion based on all included count bins.
    }
    \item{\code{dispFunctionJct}}{  
      A function that converts a base mean to a fitted dispersion based only on the splice junction bins.
    }
    \item{\code{dispFunctionExon }}{  
      A function that converts a base mean to a fitted dispersion based only on the exon bins.
    }
    \item{\code{formulas}}{  
      A list of formulas used.
    }
    \item{\code{annotationFile}}{  
      The annotation file.
    }
    \item{\code{geneCountData}}{  
      A matrix of the gene-level counts
    }
    \item{\code{countVectors}}{  
      A matrix of the count vectors.
    }
    \item{\code{altSizeFactors}}{  
      (Not currently used)
    }
    \item{\code{plottingEstimates}}{  
      A list of fitted estimates, for plotting.
    }
    \item{\code{plottingEstimatesVST }}{  
      (Not currently used)
    }
    \item{\code{geneLevelPlottingEstimates }}{  
      A list of gene-level fitted estimates, for plotting.
    }
    \item{\code{modelFitForHypothesisTest }}{  
      (Not currently used)
    }
    \item{\code{modelFitForEffectSize }}{  
      (Not currently used)
    }
    \item{\code{flatGffData}}{  
      A \code{data.frame} representation of the flattened gff annotation for each countbin.
    }
    \item{\code{flatGffGeneData}}{  
      A \code{data.frame} representation of the flattened gff annotation for each gene.
    }
    \item{\code{analysisType}}{  
      The type of analysis. Character string.
    }
    \item{\code{DESeqDataSet}}{  
      The specially-constructed \code{DESeqDataSet}, to be passed to the internally-loaded DESeq2 code.
    }

    \item{\code{modelCoefficientsSample}:}{Object of class \code{"list"}. Placeholder slot for model coefficients (used for diagnostic testing of code). }
    \item{\code{modelCoefficientsGene}:}{Object of class \code{"list"}. Placeholder slot for model coefficients (used for diagnostic testing of code). }
    
    \item{\code{assayData}:}{Object of class \code{"AssayData"}. Contains various data. }
    \item{\code{phenoData}:}{Object of class \code{"AnnotatedDataFrame"}. Phenotype data. }
    \item{\code{featureData}:}{Object of class \code{"AnnotatedDataFrame"}. Counting bin data. }
    \item{\code{experimentData}:}{Object of class \code{"MIAxE"}. Information on the experiment. }
    \item{\code{annotation}:}{Object of class \code{"character"}. Not used.}
    \item{\code{protocolData}:}{Object of class \code{"AnnotatedDataFrame"}. Information on the code. }
    \item{\code{.__classVersion__}:}{Object of class \code{"Versions"}. The version of the JunctionSeqCountSet. }
  }
}

\section{Extends}{
Class \code{"\linkS4class{eSet}"}, directly.
Class \code{"\linkS4class{VersionedBiobase}"}, by class "eSet", distance 2.
Class \code{"\linkS4class{Versioned}"}, by class "eSet", distance 3.
}

%Accessors are depreciatd. They added no functionality, and were a pain to use.
%\section{Methods}{
%  \describe{
%    \item{pData}{\code{signature(object = "JunctionSeqCountSet")}: Returns phenotype data as a data.frame object. }
%    \item{phenoData}{\code{signature(object = "JunctionSeqCountSet")}: Returns phenotype data as an AnnotatedDataFrame object. }
%    \item{fData}{\code{signature(object = "JunctionSeqCountSet")}: Returns feature data as a data.frame object. }
%    \item{featureData}{\code{signature(object = "JunctionSeqCountSet")}: Returns feature data as an AnnotatedDataFrame object. }
%
%    \item{counts}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for exon/SJ counts. }
%    \item{counts<-}{\code{signature(object = "JunctionSeqCountSet", value = "matrix")}: Replacer method for exon/SJ counts. }
%    \item{design}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for design. }
%    \item{design<-}{\code{signature(object = "JunctionSeqCountSet", value = "ANY")}: Replacer method for design. }
%    \item{jscs.altSizeFactors}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for altSizeFactors. }
%    \item{jscs.altSizeFactors<-}{\code{signature(object = "JunctionSeqCountSet", value = "data.frame")}: Replacer method for altSizeFactors.  }
%    \item{jscs.analysisType}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for analysisType.  }
%    \item{jscs.analysisType<-}{\code{signature(object = "JunctionSeqCountSet", value = "character")}:  Replacer method for analysisType. }
%    \item{jscs.annotationFile}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for annotationFile.  }
%    \item{jscs.annotationFile<-}{\code{signature(object = "JunctionSeqCountSet", value = "character")}:  Replacer method for annotationFile. }
%    \item{jscs.countVectors}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for countVectors.  }
%    \item{jscs.countVectors<-}{\code{signature(object = "JunctionSeqCountSet", value = "matrix")}: Replacer method for countVectors.  }
%    \item{jscs.DESeqDataSet}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for DESeqDataSet.  }
%    \item{jscs.DESeqDataSet<-}{\code{signature(object = "JunctionSeqCountSet", value = "DESeqDataSet")}:  Replacer method for DESeqDataSet. }
%    \item{jscs.designColumns}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for designColumns.  }
%    \item{jscs.designColumns<-}{\code{signature(object = "JunctionSeqCountSet", value = "character")}: Replacer method for designColumns.  }
%    \item{jscs.dispFitCoefs}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for dispFitCoefs.  }
%    \item{jscs.dispFitCoefs<-}{\code{signature(object = "JunctionSeqCountSet", value = "numeric")}: Replacer method for dispFitCoefs.  }
%    \item{jscs.dispFunction}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for dispFunction.  }
%    \item{jscs.dispFunction<-}{\code{signature(object = "JunctionSeqCountSet", value = "function")}: Replacer method for dispFunction.  }
%    \item{jscs.dispFunctionExon}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for dispFunctionExon.  }
%    \item{jscs.dispFunctionExon<-}{\code{signature(object = "JunctionSeqCountSet", value = "function")}: Replacer method for dispFunctionExon.  }
%    \item{jscs.dispFunctionJct}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for dispFunctionJct.  }
%    \item{jscs.dispFunctionJct<-}{\code{signature(object = "JunctionSeqCountSet", value = "function")}: Replacer method for dispFunctionJct.  }
%    \item{jscs.dispFunctionType}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for dispFunctionType.  }
%    \item{jscs.dispFunctionType<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for dispFunctionType.  }
%    \item{jscs.fittedMu}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for fittedMu.  }
%    \item{jscs.fittedMu<-}{\code{signature(object = "JunctionSeqCountSet", value = "matrix")}: Replacer method for fittedMu.  }
%    \item{jscs.flatGffData}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for flatGffData.  }
%    \item{jscs.flatGffData<-}{\code{signature(object = "JunctionSeqCountSet", value = "data.frame")}: Replacer method for flatGffData.  }
%    \item{jscs.flatGffGeneData}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for flatGffGeneData.  }
%    \item{jscs.flatGffGeneData<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for flatGffGeneData.  }
%    \item{jscs.formulas}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for formulas.  }
%    \item{jscs.formulas<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for formulas.  }
%    \item{jscs.geneCountData}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for geneCountData.  }
%    \item{jscs.geneCountData<-}{\code{signature(object = "JunctionSeqCountSet", value = "matrix")}: Replacer method for geneCountData.  }
%    \item{jscs.geneLevelPlottingEstimates}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for geneLevelPlottingEstimates.  }
%    \item{jscs.geneLevelPlottingEstimates<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for geneLevelPlottingEstimates.  }
%    \item{jscs.modelCoefficientsGene}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for modelCoefficientsGene.  }
%    \item{jscs.modelCoefficientsGene<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for modelCoefficientsGene.  }
%    \item{jscs.modelCoefficientsSample}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for modelCoefficientsSample.  }
%    \item{jscs.modelCoefficientsSample<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for modelCoefficientsSample.  }
%    \item{jscs.modelFitForEffectSize}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for modelFitForEffectSize.  }
%    \item{jscs.modelFitForEffectSize<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for modelFitForEffectSize.  }
%    \item{jscs.modelFitForHypothesisTest}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for modelFitForHypothesisTest.  }
%    \item{jscs.modelFitForHypothesisTest<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for modelFitForHypothesisTest.  }
%    \item{jscs.plottingEstimates}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for plottingEstimates.  }
%    \item{jscs.plottingEstimates<-}{\code{signature(object = "JunctionSeqCountSet", value = "list")}: Replacer method for plottingEstimates.  }
%    \item{sizeFactors}{\code{signature(object = "JunctionSeqCountSet")}: Accessor method for sizeFactors.  }
%    \item{sizeFactors<-}{\code{signature(object = "JunctionSeqCountSet", value = "numeric")}: Replacer method for sizeFactors.  }
%  }
%}

\author{
Stephen Hartley
}
\note{
End-users generally will not use any of these slots or methods directly. 
However, they may be useful for model fit diagnostics and similar 
statistical experimentation.

You can access method-mode information using the "AltMethods" attribute, and a list of all calls using the "callStack" attribute.
}

\seealso{
  The proper way to create a JunctionSeqCountSet is to use \code{\link{readJunctionSeqCounts}} or 
  \code{\link{runJunctionSeqAnalyses}}.
}

\examples{
showClass("JunctionSeqCountSet")
}

\keyword{classes}
